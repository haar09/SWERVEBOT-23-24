package frc.robot.subsystems;

import com.ctre.phoenix6.configs.CANcoderConfiguration;
import com.ctre.phoenix6.hardware.CANcoder;
import com.ctre.phoenix6.signals.AbsoluteSensorRangeValue;
import com.ctre.phoenix6.signals.SensorDirectionValue;
import com.revrobotics.CANSparkMax;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.CANSparkBase.SoftLimitDirection;

import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants.ShooterConstants;

public class Shooter extends SubsystemBase{
    
    private final CANSparkMax pivotMotor;

    private final RelativeEncoder pivotEncoder;
    private final CANcoder absoluteEncoder;

    private final PIDController anglePidController;

    public Shooter() {
        pivotMotor = new CANSparkMax(ShooterConstants.kPivotMotorId, CANSparkMax.MotorType.kBrushless);
        absoluteEncoder = new CANcoder(ShooterConstants.kAbsoluteEncoderId);

        pivotMotor.setInverted(ShooterConstants.kPivotMotorReversed);
        pivotMotor.setIdleMode(CANSparkMax.IdleMode.kBrake);

        pivotEncoder = pivotMotor.getEncoder();

        CANcoderConfiguration config = new CANcoderConfiguration();
        config.MagnetSensor.MagnetOffset = ShooterConstants.kAbsoluteEncoderOffset;
        config.MagnetSensor.AbsoluteSensorRange = AbsoluteSensorRangeValue.Signed_PlusMinusHalf;
        config.MagnetSensor.SensorDirection = SensorDirectionValue.CounterClockwise_Positive;
        absoluteEncoder.getConfigurator().apply(config);

        pivotEncoder.setPositionConversionFactor(ShooterConstants.kPivotMotorRot2Rad);
        pivotMotor.setSoftLimit(SoftLimitDirection.kForward, ShooterConstants.kMaxShooterAngleRad);
        pivotMotor.setSoftLimit(SoftLimitDirection.kReverse, 0);
        pivotMotor.enableSoftLimit(SoftLimitDirection.kForward, true);
        pivotMotor.enableSoftLimit(SoftLimitDirection.kReverse, true);

        pivotMotor.burnFlash();

        anglePidController = new PIDController(ShooterConstants.kAngleP, ShooterConstants.kAngleI, ShooterConstants.kAngleD);
        anglePidController.setTolerance(ShooterConstants.kAngleToleranceRad);
        anglePidController.enableContinuousInput(-Math.PI, Math.PI);
        
        resetEncoders();
    }

    public double getAngle(){
        return pivotEncoder.getPosition();
    }

    public double getAbsolutePosition(){
        return (absoluteEncoder.getPosition().getValueAsDouble() * 360);
    }

    public double getAbsoluteEncoderRad() {
		double angle = Math.toRadians(absoluteEncoder.getPosition().getValueAsDouble() * 360);
        return angle;
    }

    public void resetEncoders(){
        pivotEncoder.setPosition(getAbsoluteEncoderRad());
    }

    public void setDesiredAngle(double angle){
        if (Math.abs(angle) < ShooterConstants.kAngleToleranceRad) {
            stop();
            return;
        }

        if (angle > ShooterConstants.kMaxShooterAngleRad) {
            angle = ShooterConstants.kMaxShooterAngleRad;
        } else if (angle < 0) {
            angle = 0;
        }

        pivotMotor.set(anglePidController.calculate(getAngle(), angle));
    }
    
    public void stop(){
        pivotMotor.set(0);
    }

    public double getShooterHeight() {
        double shooterHeadAngle = Math.toDegrees(getAngle()) - ShooterConstants.kPivotToShooterMouthDegrees;
        double shooterMouthHeight = Math.sin(shooterHeadAngle) * ShooterConstants.kPivotToShooterMouthMeters;        
        return shooterMouthHeight + ShooterConstants.kPivotHeightMeters;
    }

    public double getShooterDistance(double apriltagToLimelight){
        double shooterHeadAngle = Math.toDegrees(getAngle()) - ShooterConstants.kPivotToShooterMouthDegrees;
        double shooterMouthBehind = Math.cos(shooterHeadAngle) * ShooterConstants.kPivotToShooterMouthMeters;
        return ShooterConstants.kPivotToCameraXDistanceMeters - shooterMouthBehind + apriltagToLimelight;
    }
}