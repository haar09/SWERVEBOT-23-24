package frc.robot.commands;

import java.util.function.Supplier;

import org.photonvision.targeting.PhotonTrackedTarget;

import edu.wpi.first.wpilibj2.command.Command;
import frc.robot.GlobalVariables;
import frc.robot.RobotContainer;
import frc.robot.Constants.ShooterConstants;
import frc.robot.subsystems.LimeLight;
import frc.robot.subsystems.ShooterPivot;

public class ShooterAutoAim extends Command {
    private final ShooterPivot m_ShooterPivot;
    private final LimeLight m_LimeLight;
    private final RotateToTargetWhileDrive m_RotateToTargetWhileDrive;

    public ShooterAutoAim(ShooterPivot shooter, LimeLight limeLight) {
        this.m_ShooterPivot = shooter;
        this.m_LimeLight = limeLight;
        this.m_RotateToTargetWhileDrive = new RotateToTargetWhileDrive(m_LimeLight);
        addRequirements(m_ShooterPivot, m_LimeLight);
    }

    double vy, airtime, vx, launch_angle;

    @Override
    public void initialize() {
        m_RotateToTargetWhileDrive.initialize();
    }

    @Override
    public void execute() {
        if (GlobalVariables.getInstance().extenderFull && m_LimeLight.isTargetValid()) {
            m_RotateToTargetWhileDrive.execute();
            for (PhotonTrackedTarget target : m_LimeLight.getTargets()) {
                if (target.getFiducialId() != 4 || target.getFiducialId() != 8) {
                    RobotContainer.rumble(1, 1, 1, 1);
                    return;
                } else {
                    RobotContainer.rumble(0, 0, 0, 0);

                    RobotContainer.rumble(0, 0, 0, 0);
                    vy = Math.sqrt(Math.pow(ShooterConstants.kAngleH, 2)
                            + (2.04 /* shooter height */ - m_ShooterPivot.getShooterHeight()) * 2 * 32); // çalışmazsa
                                                                                                         // 32-9.8 yap
                    airtime = (vy - ShooterConstants.kAngleH) / 32; // çalışmazsa 32-9.8 yap
                    vx = m_ShooterPivot.getShooterDistance(target.getBestCameraToTarget().getX()) / airtime;
                    launch_angle = Math.atan2(vy, vx);
                    m_ShooterPivot.setDesiredAngle(launch_angle);
                }
            }
        } else {
            RobotContainer.rumble(1, 1, 1, 1);
        }
    }

    public void end(boolean interrupted) {
        m_RotateToTargetWhileDrive.end(false);
        RobotContainer.rumble(0, 0, 0, 0);
    }

    @Override
    public boolean isFinished() {
        return false;
    }
}
